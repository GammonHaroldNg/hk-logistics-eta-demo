<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HK Logistics - Overview</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <link rel="stylesheet" href="/css/common.css">
    <link rel="stylesheet" href="/css/overview.css">
    <link rel="stylesheet" href="/css/tracking.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üöö HK Logistics - Overview</h1>
            <div class="nav">
            </div>
        </header>
        
        <main>
            <div id="map">
                <div class="map-loading">
                    <div style="font-size: 48px; margin-bottom: 10px;">üó∫Ô∏è</div>
                    <div>Initializing map and routes...</div>
                </div>

                <div class="map-controls">
                  <button class="btn btn-mode active" id="projectBtn">Project Routes</button>
                  <button class="btn btn-mode" id="allBtn">Traffic Status</button>
                  <button class="btn btn-primary" id="refreshBtn">Refresh</button>
                  <button class="btn btn-secondary" id="trackingBtn">Tracking</button>
                </div>
            </div>
            
            <div class="stats-panel">
              <!-- Overview mode panel -->
              <div id="overviewPanel">
                <h2>üìäProject Route Status</h2>

                <div class="stats-grid">
                  <div class="stat-item filter-stat active" data-filter="GREEN" id="statGreen" onclick="toggleFilter('GREEN')">
                    <span class="stat-label">Green</span>
                    <span class="stat-value" id="greenCount">-</span>
                  </div>
                  <div class="stat-item filter-stat active" data-filter="YELLOW" id="statYellow" onclick="toggleFilter('YELLOW')">
                    <span class="stat-label">Yellow</span>
                    <span class="stat-value" id="yellowCount">-</span>
                  </div>
                  <div class="stat-item filter-stat active" data-filter="RED" id="statRed" onclick="toggleFilter('RED')">
                    <span class="stat-label">Red</span>
                    <span class="stat-value" id="redCount">-</span>
                  </div>
                  <div class="stat-item filter-stat" data-filter="NO DATA" id="statNoData" onclick="toggleFilter('NO DATA')">
                    <span class="stat-label">No Data</span>
                    <span class="stat-value" id="blueCount">-</span>
                  </div>
                </div>


<!-- REMOVE the separate filter-buttons div entirely -->


                <h3 id="routeTitle">üìç Project Routes</h3>


                  <!-- Scrollable route list container -->
                  <div class="route-list-container">
                    <div class="route-list" id="routeList">
                      <div class="loading">
                        Loading routes...
                      </div>
                    </div>
                  </div>

                  <div class="last-update">
                    <strong>Last Update:</strong><br>
                    <span id="lastUpdate">-</span>
                  </div>
                </div>


              <!-- Project simulation panel -->
              <div id="projectPanel" style="display:none;">
                <div class="tracking-panel">
                  <div class="eta-info">
                    <h2>Concrete Delivery Overview</h2>
                    <div class="route-info-content" id="projectRouteInfo">
                      Select a project route to start simulation.
                    </div>
                  </div>

                  <div class="vehicle-list">
                    <h2>Active Concrete Vehicles</h2>
                    <div class="vehicle-list-content" id="projectVehicleList">
                      <!-- truck list goes here -->
                    </div>
                  </div>

                  <div class="eta-info">
                    <h2>Performance vs Target</h2>
                    <div class="route-info-content" id="projectPerformance">
                      <!-- delivered vs target, delay estimate -->
                    </div>
                  </div>
                </div>
              </div>
            </div>

        </main>
    </div>
    
    <script>
      var API_BASE = ''; // use same-origin
      let map = null;
      let routeLayer = null;
      let allRoutes = [];
      let currentMode = 'focused';
      let trafficDataMap = {};  // { [routeId]: { state, speed } }
      let projectMarkers = null;
      let activeFilters = new Set(['GREEN', 'YELLOW', 'RED']);
      let allProjectRoutes = [];

      function toggleFilter(filterType) {
        if (activeFilters.has(filterType)) {
          activeFilters.delete(filterType);
        } else {
          activeFilters.add(filterType);
        }
        
        // Update stat item appearance
        const btnMap = {
          'GREEN': 'statGreen',
          'YELLOW': 'statYellow',
          'RED': 'statRed',
          'NO DATA': 'statNoData'
        };
        
        const btn = document.getElementById(btnMap[filterType]);
        if (btn) {
          btn.classList.toggle('active');
        }
        
        // Re-render the route list with current filters
        renderRouteList();
      }

      function renderRouteList() {
        const routeList = document.getElementById('routeList');
        
        if (!allProjectRoutes || allProjectRoutes.length === 0) {
          routeList.innerHTML = '<div class="loading">No routes available</div>';
          return;
        }
        
        // Filter routes based on active filters
        const filteredRoutes = allProjectRoutes.filter(route => {
          const routeId = route.properties.ROUTEID;
          const traffic = trafficDataMap[routeId];
          const hasTdas = !!traffic || !!route.properties.HASTDASDATA;
          const state = hasTdas ? (traffic?.state || route.properties.TDASSTATE || 'UNKNOWN')
                                : 'NO DATA';
          
          return activeFilters.has(state);
        });
        
        if (filteredRoutes.length === 0) {
          routeList.innerHTML = '<div class="loading">No routes match the selected filters</div>';
          return;
        }
        
        routeList.innerHTML = filteredRoutes
          .map(route => {
            const routeId = route.properties.ROUTEID;
            const routeName = route.properties.Name || `Route ${routeId}`;
            const traffic = trafficDataMap[routeId];
            const hasTdas = !!traffic || !!route.properties.HASTDASDATA;
            const state = hasTdas ? (traffic?.state || route.properties.TDASSTATE || 'UNKNOWN')
                                  : 'NO DATA';
            const speed = hasTdas && typeof (traffic?.speed ?? route.properties.TRAFFICSPEED) === 'number'
              ? (traffic?.speed ?? route.properties.TRAFFICSPEED)
              : null;

            const statusClass = hasTdas
              ? `status-${state.toLowerCase()}`
              : 'status-gray';

            const speedText = hasTdas && speed !== null
              ? `${speed.toFixed(1)} km/h`
              : '-';

            return `
              <div class="route-item" onclick="zoomToRoute(${routeId})">
                <div class="route-id">${routeName}</div>
                <div class="route-status">
                  <span class="status-badge ${statusClass}">${state}</span>
                  <span style="margin-left: 8px;">${speedText}</span>
                </div>
              </div>
            `;
          })
          .join('');
      }

      function zoomToRoute(routeId) {
        if (!map || !allRoutes) return;
        
        const route = allRoutes.find(f => f.properties?.ROUTEID === routeId);
        if (!route || !route.geometry) return;
        
        const bounds = L.latLngBounds([]);
        
        let allCoords = [];
        if (route.geometry.type === 'LineString') {
          allCoords = [route.geometry.coordinates];
        } else if (route.geometry.type === 'MultiLineString') {
          allCoords = route.geometry.coordinates;
        }
        
        allCoords.forEach(coords => {
          coords.forEach(coord => {
            bounds.extend([coord[1], coord[0]]);
          });
        });
        
        if (bounds.isValid()) {
          map.fitBounds(bounds, { 
            padding: [80, 80],
            maxZoom: 15 
          });
        }
      }


      window.addEventListener('DOMContentLoaded', () => {
        console.log('‚úì Page loaded');
        console.log('API_BASE:', API_BASE);

        initMap();
        loadTrafficData();
        loadAndDisplayRoutes();
        setTimeout(function() {
          if (currentPanel === 'project') renderDeliveryForm();
        }, 2000);

        setInterval(loadTrafficData, 60000);

        if (!deliveryInterval) {
          pollDeliveryStatus();
          deliveryInterval = setInterval(pollDeliveryStatus, 3000);
        }

        document.getElementById('projectBtn').onclick = () => {
          zoomToProjectRoutes();
        };

        document.getElementById('refreshBtn').onclick = () => {
          refreshData();
        };

        document.getElementById('allBtn').onclick = () => {
          showStatusPanel(); // show traffic status for project routes
        };

        document.getElementById('trackingBtn').onclick = () => {
          showProjectPanel(); // show the ETA/estimation panel
        };

      });

      function initMap() {
        try {
          map = L.map('map').setView([22.3193, 114.1694], 11);
          L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap ¬© CartoDB',
            maxZoom: 19
          }).addTo(map);

          routeLayer = L.featureGroup().addTo(map);

          console.log('‚úì Map initialized with grey style');
        } catch (error) {
          console.error('‚úó Map init error:', error);
        }
      }

      let currentPanel = 'project'; // 'project' or 'status'

      function showProjectPanel() {
        currentPanel = 'project';
        document.getElementById('projectPanel').style.display = 'block';
        document.getElementById('overviewPanel').style.display = 'none';
         renderDeliveryForm();  // ‚Üê ADD THIS LINE
      }

      function showStatusPanel() {
        currentPanel = 'status';
        document.getElementById('projectPanel').style.display = 'none';
        document.getElementById('overviewPanel').style.display = 'block';
      }



      async function loadTrafficData() {
        try {
          console.log('‚Üí Fetching /api/traffic...');
          const response = await fetch(`${API_BASE}/api/traffic`);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();

          // Build traffic map and counters only from routes with TDAS
          trafficDataMap = {};
          let green = 0, yellow = 0, red = 0, blue = 0;

          if (data.stateMap && allRoutes) {
            const projectIds = new Set(
              allRoutes
                .filter(f => f.properties?.ISPROJECT)
                .map(f => String(f.properties.ROUTEID))
            );

            green = yellow = red = blue = 0;
            
            // Count routes with TDAS data
            for (const [routeId, state] of Object.entries(data.stateMap)) {
              if (!projectIds.has(String(routeId))) continue;

              trafficDataMap[routeId] = state;
              if (state.state === 'GREEN') green++;
              else if (state.state === 'YELLOW') yellow++;
              else if (state.state === 'RED') red++;
            }

            // Count routes WITHOUT TDAS data (blue/no data)
            for (const feature of allRoutes) {
              if (!feature.properties?.ISPROJECT) continue;
              const routeId = String(feature.properties.ROUTEID);
              if (!trafficDataMap[routeId]) {
                blue++;
              }
            }
          }

          document.getElementById('greenCount').textContent = green;
          document.getElementById('yellowCount').textContent = yellow;
          document.getElementById('redCount').textContent = red;
          document.getElementById('blueCount').textContent = blue;

          if (data.lastUpdate) {
            const time = new Date(data.lastUpdate).toLocaleTimeString('en-HK');
            document.getElementById('lastUpdate').textContent = time;
          }

          if (allProjectRoutes && allProjectRoutes.length > 0) {
            renderRouteList();
          }

          if (allRoutes && allRoutes.length > 0) {
            redrawRoutesOnMap();
          }
        } catch (error) {
          console.error('‚úó Traffic error:', error);
          document.getElementById('lastUpdate').textContent = 'Error';
        }
      }

      function redrawRoutesOnMap() {
        if (!routeLayer || !allRoutes) return;

        // Clear existing routes
        routeLayer.clearLayers();

        let routesAdded = 0;

        for (const feature of allRoutes) {
          try {
            if (!feature.geometry) continue;
            if (feature.geometry.type !== 'LineString' &&
                feature.geometry.type !== 'MultiLineString') continue;

            const routeId = feature.properties?.ROUTEID;
            const isProject = feature.properties?.ISPROJECT;

            // Get TDAS from trafficDataMap (updated data)
            const trafficState = trafficDataMap[routeId];
            const state = trafficState?.state || feature.properties?.TDASSTATE || 'UNKNOWN';
            const hasTdas = !!trafficState || !!feature.properties?.HASTDASDATA;

            const color = getColorForState(state, isProject, hasTdas);
            const weight = isProject ? 5 : 2;
            const opacity = hasTdas ? (isProject ? 0.9 : 0.5) : 0.5;

            let allCoords = [];
            if (feature.geometry.type === 'LineString') {
              allCoords = [feature.geometry.coordinates];
            } else if (feature.geometry.type === 'MultiLineString') {
              allCoords = feature.geometry.coordinates;
            }

            for (const coords of allCoords) {
              if (!coords || coords.length === 0) continue;
              const latLngs = coords.map(coord => [coord[1], coord[0]]);

              L.polyline(latLngs, {
                color,
                weight,
                opacity
              }).addTo(routeLayer);

              routesAdded++;
            }
          } catch (e) {
            console.warn('Error redrawing route:', e);
          }
        }

        console.log('‚úì Routes redrawn on map:', routesAdded, 'segments');
      }



      async function loadAndDisplayRoutes() {
        try {
          console.log(`‚Üí Loading routes in ${currentMode} mode...`);

          const url = `${API_BASE}/api/routes?mode=${currentMode}`;
          console.log(`‚Üí Fetching ${url}...`);
          const response = await fetch(url);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const geoData = await response.json();
          console.log('‚úì Routes data:', geoData.features?.length, 'routes');

          // ADD THIS DEBUG CODE:
          if (geoData.features && geoData.features.length > 0) {
            console.log('First route properties:', geoData.features[0].properties);
            console.log('Available property keys:', Object.keys(geoData.features[0].properties));
          }

          if (!geoData.features || geoData.features.length === 0) {
            const routeList = document.getElementById('routeList');
            routeList.innerHTML = '<div class="loading">No routes</div>';
            return;
          }

          allRoutes = geoData.features;

          if (routeLayer) routeLayer.clearLayers();

          let routesAdded = 0;
          const projectRoutes = [];

          for (const feature of geoData.features) {
            try {
              if (!feature.geometry) continue;
              if (feature.geometry.type !== 'LineString' &&
                  feature.geometry.type !== 'MultiLineString') continue;

              const routeId = feature.properties?.ROUTEID;
              const isProject = feature.properties?.ISPROJECT;

              // Get TDAS from trafficDataMap first, fallback to properties
              const trafficState = trafficDataMap[routeId];
              const state = trafficState?.state || feature.properties?.TDASSTATE || 'UNKNOWN';
              const speed = trafficState?.speed ??
                            (typeof feature.properties?.TRAFFICSPEED === 'number'
                              ? feature.properties.TRAFFICSPEED
                              : null);
              const hasTdas = !!trafficState || !!feature.properties?.HASTDASDATA;

              const color = getColorForState(state, isProject, hasTdas);
              const weight = isProject ? 5 : 2;
              const opacity = hasTdas ? (isProject ? 0.9 : 0.5) : 0.5;

              let allCoords = [];
              if (feature.geometry.type === 'LineString') {
                allCoords = [feature.geometry.coordinates];
              } else if (feature.geometry.type === 'MultiLineString') {
                allCoords = feature.geometry.coordinates;
              }

              for (const coords of allCoords) {
                if (!coords || coords.length === 0) continue;
                const latLngs = coords.map(coord => [coord[1], coord[0]]);

                L.polyline(latLngs, {
                  color,
                  weight,
                  opacity
                }).addTo(routeLayer);

                routesAdded++;
              }

              if (isProject) {
                projectRoutes.push({
                  ...feature,
                  properties: {
                    ...feature.properties,
                    TDASSTATE: state,
                    TRAFFICSPEED: speed,
                    HASTDASDATA: hasTdas
                  }
                });
              }
            } catch (e) {
              console.warn('Error drawing route:', e);
            }
          }

          console.log('‚úì Routes drawn on map:', routesAdded, 'segments');

          // Store all project routes globally for filtering
          allProjectRoutes = projectRoutes;

          // Render the route list with current filters
          renderRouteList();

        } catch (error) {
          console.error('‚úó Routes error:', error);
          const routeList = document.getElementById('routeList');
          routeList.innerHTML = '<div class="loading">Error: ' + error.message + '</div>';
        }
      }


      function getColorForState(state, isProject, hasTdas) {
        // No TDAS: neutral grey
        if (!hasTdas) return '#00B0F0';

        if (state === 'GREEN') return '#22c55e';
        if (state === 'YELLOW') return '#eab308';
        if (state === 'RED') return '#ef4444';
        return '#4b5563'; // unknown
      }

      function refreshData() {
        console.log('üîÑ Refreshing data...');
        loadTrafficData();
        loadAndDisplayRoutes();
      }

      function goToTracking(routeId) {
        window.location.href = `/tracking?route=${routeId}`;
      }

      function zoomToProjectRoutes() {
        if (!map || !allRoutes) return;

        const projectFeatures = allRoutes.filter(
          f => f.properties?.ISPROJECT
        );
        if (!projectFeatures.length) return;

        // Clear existing markers
        if (projectMarkers) {
          projectMarkers.clearLayers();
        } else {
          projectMarkers = L.featureGroup().addTo(map);
        }

        // Your specific start and end coordinates
        const startPoint = [22.41475986, 113.99064608];  // [lat, lng]
        const endPoint = [22.51755036, 114.0741744];     // [lat, lng]

        const bounds = L.latLngBounds([]);

        // Collect bounds from project routes
        projectFeatures.forEach(f => {
          let allCoords = [];
          if (f.geometry.type === 'LineString') {
            allCoords = [f.geometry.coordinates];
          } else if (f.geometry.type === 'MultiLineString') {
            allCoords = f.geometry.coordinates;
          }
          allCoords.forEach(coords => {
            coords.forEach(coord => {
              bounds.extend([coord[1], coord[0]]);
            });
          });
        });

        // Add start and end points to bounds
        bounds.extend(startPoint);
        bounds.extend(endPoint);

        // Add start marker (green with "S")
        const startIcon = L.divIcon({
          className: 'custom-marker',
          html: '<div style="background-color: #22c55e; width: 28px; height: 28px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 14px;">S</div>',
          iconSize: [28, 28],
          iconAnchor: [14, 14]
        });
        
        L.marker(startPoint, { icon: startIcon })
          .bindPopup('<b>üè≠ Start Point</b><br>Concrete Plant<br>Coordinates: 22.41476, 113.99065')
          .addTo(projectMarkers);

        // Add end marker (red with "E")
        const endIcon = L.divIcon({
          className: 'custom-marker',
          html: '<div style="background-color: #ef4444; width: 28px; height: 28px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 14px;">E</div>',
          iconSize: [28, 28],
          iconAnchor: [14, 14]
        });
        
        L.marker(endPoint, { icon: endIcon })
          .bindPopup('<b>üèóÔ∏è End Point</b><br>Construction Site<br>Coordinates: 22.51755, 114.07417')
          .addTo(projectMarkers);

        // Zoom to show all project routes and markers
        if (bounds.isValid()) {
          map.fitBounds(bounds, { padding: [60, 60] });
        }
      }


    </script>
    <script src="js/delivery.js"></script>
</body>
</html>